{"meta":{"title":"JunWei Song' Blog","subtitle":"Code it, and break it","description":"","author":"JunWei Song","url":"https://krnick.github.io"},"pages":[{"title":"About","date":"2021-09-30T08:34:35.889Z","updated":"2021-09-30T08:34:35.889Z","comments":false,"path":"about/index.html","permalink":"https://krnick.github.io/about/index.html","excerpt":"","text":"Hi there 👋Who am IJunWei is a security researcher and open-source enthusiast from Taiwan. A paranoid Pythonista and CPython contributor who now focuses on Android reverse engineering and malware analysis. And as a member of the PyCon Taiwan Program Committee, previously presented at Black Hat, DEFCON, HITB, ROOTCON, GrayHat, PyCon Europe/TW/KR/MY/IN. He’s the co-founder of Quark-Engine and the Quark package maintainer on Kali Linux, leading Quark to participate in the GSoC under the Honeynet Project since 2021. Google summer of code 2021 Mentor My Previous Talks The projects I am currently working on: Resume (English Version)","raw":null,"content":null},{"title":"Categories","date":"2020-09-23T05:06:09.000Z","updated":"2021-09-30T08:34:35.890Z","comments":false,"path":"categories/index.html","permalink":"https://krnick.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"Tags","date":"2020-09-23T05:06:01.000Z","updated":"2021-09-30T08:34:35.890Z","comments":false,"path":"tags/index.html","permalink":"https://krnick.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"CPython zipfile module code tracing for zip bomb vulnerability","slug":"CPython-zipfile-Code-Tracing","date":"2021-09-30T08:39:10.000Z","updated":"2021-09-30T09:40:52.573Z","comments":true,"path":"2021/09/30/CPython-zipfile-Code-Tracing/","link":"","permalink":"https://krnick.github.io/2021/09/30/CPython-zipfile-Code-Tracing/","excerpt":"","text":"BackgroundI reported a zip bomb vulnerability to the CPython community in 2019. Here are all the interesting resources and ideas. Issue Discussion on BPO CVE-2019-9674 Decompression pitfall I wrote for official documentation Pull Request related it PyCon Korea 2019 - Click Click Boom! Bombs Over Our Minds zipfile analysisAccording to Black Hat’s Cara Marie research, there are some solutions against Zip Bomb. By limiting the size of the block to be read at a time, if there is still data remaining after the block that needs to be decompressed after reading this block, it is considered that it is possible to be a Zip Bomb. Below is Cara Marie code 12345678import zlibdef decompress(data, maxsize=1024000): dec = zlib.decompressobj() data = dec.decompress(data, maxsize) if dec.unconsumed_tail: raise ValueError(&quot;Possible bomb&quot;) del dec return data As you can see, the strategy to defeating the zip bomb is by limiting a block, in this case, is max size 102400. However, we take a look at the Python standard library, zipfile. According to Cara Marie’s approach, we try to figure out the difference between zipfile and zlib and why we can’t use zipfile directly for preventing zip bombs, so we started to study zipfile source code. zipfileSince I focus on the zip format and pick the most commonly used algorithm, DEFLATED algorithm. Inside the zipfile, we can see the location of unzipped function, starting at line 702, getting the zlib object, and finally returning the object. zlib.decompressobj(-15) 123456789101112131415def _get_decompressor(compress_type): if compress_type == ZIP_STORED: return None elif compress_type == ZIP_DEFLATED: return zlib.decompressobj(-15) elif compress_type == ZIP_BZIP2: return bz2.BZ2Decompressor() elif compress_type == ZIP_LZMA: return LZMADecompressor() else: descr = compressor_names.get(compress_type) if descr: raise NotImplementedError(&quot;compression type %d (%s)&quot; % (compress_type, descr)) else: raise NotImplementedError(&quot;compression type %d&quot; % (compress_type,)) From the above code, we can know that the zipfile is based on what zlib does. So we have to deep dive into what zlib did? zlibAccording to the zlib documentation There are two ways to compression and decompression, .compress() and .decompress() will fit all files into memory at once. In contrast to the method of the object. It using .compressobj() and .decompressobj() which won’t fit into memory at once. There are two ways to compress/decompress. .compress() and .decompress() will put the entire file into memory at a time .compressobj() and .decompressobj() separate the file , compress/decompress one block at a time However, the official documentation does not clearly explain how to use the API to decompress files. The purpose of this method is to obtain the file data stream and decompress it through the Low-Level method. And we went back to the zipfile module and found that they had already done the decompression of zlib, so we planned to apply the patch for zipfile first. In the way that zipfile belongs to decompressobj, we have the first way to accumulate chunks. As long as we can find out where to do the decompression of chunks, we accumulate it and give a threshold. If it exceeds, then consider that it is possible to be the zip bomb. Get back at the zipfile Starting with the object Line 706 1return zlib.decompressobj(-15) Line 791 It is the place where the class of zlib.decompressobj(-15) object is obtained and initialized. which belongs to ZipExtFile class 1def __init__(self, fileobj, mode, zipinfo, decrypter=None,close_fileobj=False): Let’s find out what fileobj is Line 1545 1return ZipExtFile(zef_file, mode, zinfo, zd, True) Return the class, and use zef_file, then follow zef_file Line 719 _SharedFile being initialized 1def __init__(self, file, pos, close, lock, writing): Here we know that when zlib is decompressed, you can’t start decompressing directly to Streaming, and you need to skip the file encoding in front of the zip file. Line 759 In class _Tellable: to initialize the position of the indicator that gets the file descriptor 123def __init__(self, fp): self.fp = fp self.offset = 0 and then Line 977 12345678910elif self._compress_type == ZIP_DEFLATED: n = max(n, self.MIN_READ_SIZE) data = self._decompressor.decompress(data, n) self._eof = (self._decompressor.eof or self._compress_left &lt;= 0 and not self._decompressor.unconsumed_tail) if self._eof: data += self._decompressor.flush() We observed that after choosing to use the ZIP_DEFLATED compression algorithm, we did a function max to get n. Key Point1max(n, self.MIN_READ_SIZE) When you use zlib.decompressobj as a block, how big is your block?, self.MIN_READ_SIZE is preset to 4096 bytes, which is the size of a page in the operating system. Cara Marie’s solution12345678import zlibdef decompress(data, maxsize=1024000): dec = zlib.decompressobj() data = dec.decompress(data, maxsize) if dec.unconsumed_tail: raise ValueError(&quot;Possible bomb&quot;) del dec return data It sets maxsize to 102400 bytesAccording to the official document Decompress.decompress(data, max_length=0)Decompress data, returning a bytes object containing the uncompressed data corresponding to at least part of the data in the string. This data should be concatenated to the output produced by any preceding calls to the decompress() method. Some of the input data may be preserved in internal buffers for later processing. If the optional parameter max_length is non-zero then the return value will be no longer than max_length. This may mean that not all of the compressed input can be processed, and unconsumed data will be stored in the attribute unconsumed_tail. This byte string must be passed to a subsequent call to decompress() if decompression is to continue. If max_length is zero then the whole input is decompressed, and unconsumed_tail is empty. Changed in version 3.6: max_length can be used as a keyword argument. Max_length represents the file block size that can be read into the memory at a time and is marked with unconsumed_tail to see if any remaining files need to be decompressed. Therefore, his idea is more than 102400 bytes. If there is any remaining data, it means there may be a zip bomb.","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Debian Packaging","slug":"Debian-Packaging","date":"2021-05-03T08:10:42.000Z","updated":"2021-09-30T08:34:35.888Z","comments":true,"path":"2021/05/03/Debian-Packaging/","link":"","permalink":"https://krnick.github.io/2021/05/03/Debian-Packaging/","excerpt":"","text":"前陣子要將 Quark 上傳至 Kali Linux，需要包成一個 Debian 的安裝檔案費了不少力氣，以下紀錄一下該如何打包一個 Python 專案至 Debian 的 .deb 安裝檔案。 Kali Linux issue 0007121 Creating the Debian filesDebian套件強制規定 debian 目錄下需要有以下四個檔案 control copyright changelog rules 細節可參考 Quark 完成後的 Debian-目錄 產生 debian 目錄使用 dh_make 可以自動幫你產生所需的這四個檔案，quark-engine_21.02.2.orig.tar.gz 為你的專案壓縮檔案。 123dh_make -p quark-engine_21.02.2 -f quark-engine_21.02.2.orig.tar.gz rm *.ex *.EX README.* *.docs System Requirements更新環境 123echo &quot;deb http://http.kali.org/kali kali-rolling main non-free contrib&quot; | sudo tee /etc/apt/sources.listsudo apt-get update 安裝需要的檔案 123sudo apt install -y packaging-dev apt-file gitk mrsudo apt-get install -y devscripts debhelper dh-make git-buildpackage sbuild dh-python python3-all 設定 sbuild，完成後重新登入 12345678sudo mkdir -p /srv/chroots/cd /srv/chroots/sudo sbuild-createchroot --keyring=/usr/share/keyrings/kali-archive-keyring.gpg --arch=amd64 --components=main,contrib,non-free --include=kali-archive-keyring kali-dev kali-dev-amd64-sbuild http://http.kali.org/kaliecho &quot;source-root-groups=root,sbuild&quot; | sudo tee -a /etc/schroot/chroot.d/kali-dev-amd64-sbuild*sudo sbuild-adduser $USER Importing匯入你的專案 12345678910mkdir -p ~/kali/packages/quark-engine ~/kali/upstream/wget https://github.com/quark-engine/quark-engine/archive/refs/tags/v21.4.3.tar.gz -O ~/kali/upstream/quark-engine_21.4.3.orig.tar.gzcd /home/kali/kali/packages/quark-enginegit initgbp import-orig ~/kali/upstream/quark-engine_21.4.3.orig.tar.gz Build Package產生 .deb 檔案 1gbp buildpackage --git-builder=sbuild Referencehttps://www.kali.org/docs/development/public-packaging/https://www.kali.org/docs/development/intro-to-packaging-example/https://www.kali.org/docs/development/setting-up-packaging-system/https://www.kali.org/docs/development/advanced-packaging-example/","raw":null,"content":null,"categories":[],"tags":[{"name":"Debian","slug":"Debian","permalink":"https://krnick.github.io/tags/Debian/"},{"name":"Linux","slug":"Linux","permalink":"https://krnick.github.io/tags/Linux/"},{"name":"Kali Linux","slug":"Kali-Linux","permalink":"https://krnick.github.io/tags/Kali-Linux/"}]},{"title":"pipenv","slug":"pipenv","date":"2020-09-24T06:15:06.000Z","updated":"2021-09-30T08:34:35.889Z","comments":true,"path":"2020/09/24/pipenv/","link":"","permalink":"https://krnick.github.io/2020/09/24/pipenv/","excerpt":"","text":"Install from github1pipenv install -e git+https://github.com/quark-engine/quark-engine.git#egg=quark-engine First “quark-enigne”: user Second “quark-engine”: repo @develop: The branch what you want to install #egg=quark-engine: The package name that will be recorded in pipenv","raw":null,"content":null,"categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://krnick.github.io/tags/python/"},{"name":"git","slug":"git","permalink":"https://krnick.github.io/tags/git/"}]}]}
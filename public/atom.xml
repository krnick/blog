<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JunWei Song&#39; Blog</title>
  
  <subtitle>Security Complete Me</subtitle>
  <link href="https://krnick.github.io/atom.xml" rel="self"/>
  
  <link href="https://krnick.github.io/"/>
  <updated>2021-09-30T08:49:11.126Z</updated>
  <id>https://krnick.github.io/</id>
  
  <author>
    <name>JunWei Song</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CPython zipfile Code Tracing</title>
    <link href="https://krnick.github.io/2021/09/30/CPython-zipfile-Code-Tracing/"/>
    <id>https://krnick.github.io/2021/09/30/CPython-zipfile-Code-Tracing/</id>
    <published>2021-09-30T08:39:10.000Z</published>
    <updated>2021-09-30T08:49:11.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Goal："><a href="#Goal：" class="headerlink" title="Goal："></a>Goal：</h1><p>zipfile analysis</p><p>According to Black Hat’s  <a href="https://www.blackhat.com/docs/us-16/materials/us-16-Marie-I-Came-to-Drop-Bombs-Auditing-The-Compression-Algorithm-Weapons-Cache.pdf">Cara Marie</a> research, there are some solutions against Zip Bomb. By limiting the size of the block to be read at a time, if there is still data remaining after the block needs to be decompressed after reading this block, it is considered that it is possible to be Zip Bomb.</p><p>Here is <a href="https://www.blackhat.com/docs/us-16/materials/us-16-Marie-I-Came-to-Drop-Bombs-Auditing-The-Compression-Algorithm-Weapons-Cache.pdf">Cara Marie</a> code</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decompress</span>(<span class="params">data, maxsize=<span class="number">1024000</span></span>):</span></span><br><span class="line">    dec = zlib.decompressobj()</span><br><span class="line">    data = dec.decompress(data, maxsize)</span><br><span class="line">    <span class="keyword">if</span> dec.unconsumed_tail:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Possible bomb&quot;</span>)</span><br><span class="line">    <span class="keyword">del</span> dec</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>As you can see, the key point to against the zip bomb is by limiting a block, in this case, is max size 102400. However, we take a look at python zipfile standard library zipfile.</p><hr><p>According to Cara Marie’s method, we try to figure out the difference between zipfile and zlib, why can’t we use zipfile directly for defending, so we started to study zipfile source code.</p><h1 id="zipfile"><a href="#zipfile" class="headerlink" title="zipfile"></a><a href="https://github.com/python/cpython/blob/master/Lib/zipfile.py">zipfile</a></h1><p>Since we focus on the zip format and prefer the DEFLATED algorithm, in the zipfile we can see the key unzipped file location, starting at line 702, getting the zlib object, and finally returning the object.</p><p><strong>zlib.decompressobj(-15)</strong></p><p><a href="https://github.com/python/cpython/blob/f2320b37d9c85d8ddfc0c6afa81b77cd5f6e5ef2/Lib/zipfile.py#L702-L716">https://github.com/python/cpython/blob/f2320b37d9c85d8ddfc0c6afa81b77cd5f6e5ef2/Lib/zipfile.py#L702-L716</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_decompressor</span>(<span class="params">compress_type</span>):</span></span><br><span class="line">    <span class="keyword">if</span> compress_type == ZIP_STORED:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">elif</span> compress_type == ZIP_DEFLATED:</span><br><span class="line">        <span class="keyword">return</span> zlib.decompressobj(<span class="number">-15</span>)</span><br><span class="line">    <span class="keyword">elif</span> compress_type == ZIP_BZIP2:</span><br><span class="line">        <span class="keyword">return</span> bz2.BZ2Decompressor()</span><br><span class="line">    <span class="keyword">elif</span> compress_type == ZIP_LZMA:</span><br><span class="line">        <span class="keyword">return</span> LZMADecompressor()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        descr = compressor_names.get(compress_type)</span><br><span class="line">        <span class="keyword">if</span> descr:</span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;compression type %d (%s)&quot;</span> % (compress_type, descr))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;compression type %d&quot;</span> % (compress_type,))</span><br></pre></td></tr></table></figure><p>From this, we can know that the zipfile is based on what zlib does. So we have to deep dive into what zlib did?</p><h1 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a><a href="https://docs.python.org/3/library/zlib.html">zlib</a></h1><p>According to the Zlib documentation</p><blockquote><p>There are two ways to compression and decompression,.compress() and .decompress() will fit all files into memory at once. Contrast to the method of the object. It using .compressobj() and .decompressobj() which won’t fit into memory at once.</p></blockquote><p>There are two ways to compress/decompress.</p><ul><li>.compress() and .decompress() will put the entire file into memory at a time</li><li>.compressobj() and .decompressobj() separate the file , compress/decompress one block at a time</li></ul><hr><p>However, in the official documentation, there is no clear explanation of how to use the API to decompress the file. The usage in this way is to obtain the file data stream and decompress it through the Low-Level method. And we went back to the zipfile module, and found that they have done zlib for decompression, so we intend to consider the zipfile first, to give the patch.</p><p>In the way that zipfile belongs to decompressobj, we have the first way to accumulate Chunk. As long as we can find out where to do the decompression of Chunk, we accumulate it and give a threshold. If it exceeds, then consider that it is possible to be the Zip Bomb.</p><h1 id="Go-back-at-the-zipfile"><a href="#Go-back-at-the-zipfile" class="headerlink" title="Go back at the zipfile"></a>Go back at the zipfile</h1><ol><li>Starting with the object</li></ol><p><a href="https://github.com/python/cpython/blob/f2320b37d9c85d8ddfc0c6afa81b77cd5f6e5ef2/Lib/zipfile.py#L706">Line 706</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> zlib.decompressobj(<span class="number">-15</span>)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/python/cpython/blob/f2320b37d9c85d8ddfc0c6afa81b77cd5f6e5ef2/Lib/zipfile.py#L791">Line 791</a></p><p>It is the place where the class of zlib.decompressobj(-15) object is obtained and initialized.</p><p>which belongs to ZipExtFile class</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, fileobj, mode, zipinfo, decrypter=None,close_fileobj=False</span>):</span></span><br></pre></td></tr></table></figure><p>Let’s find out what filefilej is</p><p><a href="https://github.com/python/cpython/blob/f2320b37d9c85d8ddfc0c6afa81b77cd5f6e5ef2/Lib/zipfile.py#L1545">Line 1545</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ZipExtFile(zef_file, mode, zinfo, zd, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>Return the class, and use zef_file, then follow zef_file</p><p><a href="https://github.com/python/cpython/blob/f2320b37d9c85d8ddfc0c6afa81b77cd5f6e5ef2/Lib/zipfile.py#L719">Line 719</a></p><p>_SharedFile being initialized</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, file, pos, close, lock, writing</span>):</span></span><br></pre></td></tr></table></figure><p>Here we know that when zlib is decompressed, you can’t start decompressing directly to Streaming, and you need to skip the file encoding in front of the zip file.</p><p><a href="https://github.com/python/cpython/blob/f2320b37d9c85d8ddfc0c6afa81b77cd5f6e5ef2/Lib/zipfile.py#L759">Line 759</a></p><p>In class _Tellable: to initialize the position of the indicator that gets the file descriptor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, fp</span>):</span></span><br><span class="line">    self.fp = fp</span><br><span class="line">    self.offset = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>and then</p><p><a href="https://github.com/python/cpython/blob/f2320b37d9c85d8ddfc0c6afa81b77cd5f6e5ef2/Lib/zipfile.py#L977-L984">Line 977</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">elif</span> self._compress_type == ZIP_DEFLATED:</span><br><span class="line">    n = max(n, self.MIN_READ_SIZE)</span><br><span class="line">    data = self._decompressor.decompress(data, n)</span><br><span class="line">    self._eof = (self._decompressor.eof <span class="keyword">or</span></span><br><span class="line">                 self._compress_left &lt;= <span class="number">0</span> <span class="keyword">and</span></span><br><span class="line">                 <span class="keyword">not</span> self._decompressor.unconsumed_tail)</span><br><span class="line">    <span class="keyword">if</span> self._eof:</span><br><span class="line">        data += self._decompressor.flush()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>We observed that after choosing to use the ZIP_DEFLATED compression algorithm, we did a function max to get n .</p><h1 id="Key-Point"><a href="#Key-Point" class="headerlink" title="Key Point"></a>Key Point</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max(n, self.MIN_READ_SIZE)</span><br></pre></td></tr></table></figure><p>When you use zlib.decompressobj as a block, how big is your block?<br>, self.MIN_READ_SIZE is preset to 4096 bytes, which is the size of a page in the operating system.</p><h2 id="Black-Hat’s-solution"><a href="#Black-Hat’s-solution" class="headerlink" title="Black Hat’s solution"></a>Black Hat’s solution</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decompress</span>(<span class="params">data, maxsize=<span class="number">1024000</span></span>):</span></span><br><span class="line">    dec = zlib.decompressobj()</span><br><span class="line">    data = dec.decompress(data, maxsize)</span><br><span class="line">    <span class="keyword">if</span> dec.unconsumed_tail:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Possible bomb&quot;</span>)</span><br><span class="line">    <span class="keyword">del</span> dec</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><h2 id="It-sets-maxsize-to-102400-bytes"><a href="#It-sets-maxsize-to-102400-bytes" class="headerlink" title="It sets maxsize to 102400 bytes"></a>It sets maxsize to 102400 bytes</h2><p>According to the official document</p><blockquote><p>Decompress.decompress(data, max_length=0)<br>Decompress data, returning a bytes object containing the uncompressed data corresponding to at least part of the data in the string. This data should be concatenated to the output produced by any preceding calls to the decompress() method. Some of the input data may be preserved in internal buffers for later processing.</p><p>If the optional parameter max_length is non-zero then the return value will be no longer than max_length. This may mean that not all of the compressed input can be processed, and unconsumed data will be stored in the attribute unconsumed_tail. This byte string must be passed to a subsequent call to decompress() if decompression is to continue. If max_length is zero then the whole input is decompressed, and unconsumed_tail is empty.</p><p>Changed in version 3.6: max_length can be used as a keyword argument.</p></blockquote><p>Max_length represents the file block size that can be read into the memory at a time and is marked with unconsumed_tail to see if any remaining files need to be decompressed.</p><p>Therefore, his idea is more than 102400 bytes. If there is any remaining data, it means there may be a zip bomb.</p><p><img src="https://i.imgur.com/7schHy0.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Goal：&quot;&gt;&lt;a href=&quot;#Goal：&quot; class=&quot;headerlink&quot; title=&quot;Goal：&quot;&gt;&lt;/a&gt;Goal：&lt;/h1&gt;&lt;p&gt;zipfile analysis&lt;/p&gt;
&lt;p&gt;According to Black Hat’s  &lt;a href=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Debian Packaging</title>
    <link href="https://krnick.github.io/2021/05/03/Debian-Packaging/"/>
    <id>https://krnick.github.io/2021/05/03/Debian-Packaging/</id>
    <published>2021-05-03T08:10:42.000Z</published>
    <updated>2021-09-30T08:34:35.888Z</updated>
    
    <content type="html"><![CDATA[<p>前陣子要將 Quark 上傳至 <a href="https://www.kali.org/">Kali Linux</a>，需要包成一個 Debian 的安裝檔案費了不少力氣，以下紀錄一下該如何打包一個 Python 專案至 Debian 的 .deb 安裝檔案。</p><p><a href="https://bugs.kali.org/view.php?id=7121">Kali Linux issue 0007121</a></p><h2 id="Creating-the-Debian-files"><a href="#Creating-the-Debian-files" class="headerlink" title="Creating the Debian files"></a>Creating the Debian files</h2><p>Debian套件強制規定 debian 目錄下需要有以下四個檔案</p><ul><li>control</li><li>copyright</li><li>changelog</li><li>rules</li></ul><p>細節可參考 Quark 完成後的 <a href="https://github.com/quark-engine/quark-engine/tree/master/debian">Debian-目錄</a></p><hr><h3 id="產生-debian-目錄"><a href="#產生-debian-目錄" class="headerlink" title="產生 debian 目錄"></a>產生 debian 目錄</h3><p>使用 <code>dh_make</code> 可以自動幫你產生所需的這四個檔案，<code>quark-engine_21.02.2.orig.tar.gz</code> 為你的專案壓縮檔案。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dh_make -p quark-engine_21.02.2 -f quark-engine_21.02.2.orig.tar.gz </span><br><span class="line"></span><br><span class="line">rm *.ex *.EX README.* *.docs</span><br></pre></td></tr></table></figure><h2 id="System-Requirements"><a href="#System-Requirements" class="headerlink" title="System Requirements"></a>System Requirements</h2><p>更新環境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb http://http.kali.org/kali kali-rolling main non-free contrib&quot;</span> | sudo tee /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>安裝需要的檔案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y packaging-dev apt-file gitk mr</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y devscripts debhelper dh-make git-buildpackage sbuild dh-python python3-all</span><br></pre></td></tr></table></figure><p>設定 sbuild，完成後重新登入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /srv/chroots/</span><br><span class="line"><span class="built_in">cd</span> /srv/chroots/</span><br><span class="line"></span><br><span class="line">sudo sbuild-createchroot --keyring=/usr/share/keyrings/kali-archive-keyring.gpg --arch=amd64 --components=main,contrib,non-free --include=kali-archive-keyring kali-dev kali-dev-amd64-sbuild http://http.kali.org/kali</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source-root-groups=root,sbuild&quot;</span> | sudo tee -a /etc/schroot/chroot.d/kali-dev-amd64-sbuild*</span><br><span class="line"></span><br><span class="line">sudo sbuild-adduser <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><h2 id="Importing"><a href="#Importing" class="headerlink" title="Importing"></a>Importing</h2><p>匯入你的專案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mkdir -p ~/kali/packages/quark-engine ~/kali/upstream/</span><br><span class="line"></span><br><span class="line">wget https://github.com/quark-engine/quark-engine/archive/refs/tags/v21.4.3.tar.gz  -O ~/kali/upstream/quark-engine_21.4.3.orig.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/kali/kali/packages/quark-engine</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">gbp import-orig ~/kali/upstream/quark-engine_21.4.3.orig.tar.gz</span><br></pre></td></tr></table></figure><h2 id="Build-Package"><a href="#Build-Package" class="headerlink" title="Build Package"></a>Build Package</h2><p>產生 <code>.deb</code> 檔案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gbp buildpackage --git-builder=sbuild</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.kali.org/docs/development/public-packaging/">https://www.kali.org/docs/development/public-packaging/</a><br><a href="https://www.kali.org/docs/development/intro-to-packaging-example/">https://www.kali.org/docs/development/intro-to-packaging-example/</a><br><a href="https://www.kali.org/docs/development/setting-up-packaging-system/">https://www.kali.org/docs/development/setting-up-packaging-system/</a><br><a href="https://www.kali.org/docs/development/advanced-packaging-example/">https://www.kali.org/docs/development/advanced-packaging-example/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前陣子要將 Quark 上傳至 &lt;a href=&quot;https://www.kali.org/&quot;&gt;Kali Linux&lt;/a&gt;，需要包成一個 Debian 的安裝檔案費了不少力氣，以下紀錄一下該如何打包一個 Python 專案至 Debian 的 .deb 安裝檔案。&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="Debian" scheme="https://krnick.github.io/tags/Debian/"/>
    
    <category term="Linux" scheme="https://krnick.github.io/tags/Linux/"/>
    
    <category term="Kali Linux" scheme="https://krnick.github.io/tags/Kali-Linux/"/>
    
  </entry>
  
  <entry>
    <title>pipenv</title>
    <link href="https://krnick.github.io/2020/09/24/pipenv/"/>
    <id>https://krnick.github.io/2020/09/24/pipenv/</id>
    <published>2020-09-24T06:15:06.000Z</published>
    <updated>2021-09-30T08:34:35.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Install-from-github"><a href="#Install-from-github" class="headerlink" title="Install from github"></a>Install from github</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv install -e git+https://github.com/quark-engine/quark-engine.git<span class="comment">#egg=quark-engine</span></span><br></pre></td></tr></table></figure><ul><li>First “quark-enigne”: user</li><li>Second “quark-engine”: repo</li><li>@develop: The branch what you want to install</li><li>#egg=quark-engine: The package name that will be recorded in pipenv</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Install-from-github&quot;&gt;&lt;a href=&quot;#Install-from-github&quot; class=&quot;headerlink&quot; title=&quot;Install from github&quot;&gt;&lt;/a&gt;Install from github&lt;/h1&gt;&lt;figu</summary>
      
    
    
    
    
    <category term="python" scheme="https://krnick.github.io/tags/python/"/>
    
    <category term="git" scheme="https://krnick.github.io/tags/git/"/>
    
  </entry>
  
</feed>
